# IEEE 1800.2 Standard 

This document maps the IEEE 1800.2-2020 (UVM) standard sections to our study modules and identifies any gaps.

## IEEE 1800.2 Standard Structure

The IEEE 1800.2-2020 standard (Universal Verification Methodology Language Reference Manual) is organized into the following main sections:

1. **Introduction and Scope**
2. **Normative References**
3. **Definitions**
4. **Base Classes**
5. **Phasing**
6. **TLM (Transaction-Level Modeling)**
7. **Reporting**
8. **Configuration**
9. **Factory Pattern**
10. **Sequences and Sequencers**
11. **Register Layer**
12. **Miscellaneous Utilities**

## Coverage Mapping

#### 1. Base Classes (IEEE 1800.2 Section 4)
**Coverage**: ✅ **Fully Covered**

**Module 3: UVM Basics**
- `uvm_object` vs `uvm_component` (covered)
- Component classes: `uvm_test`, `uvm_env`, `uvm_agent`, `uvm_driver`, `uvm_monitor`, `uvm_sequencer` (covered)
- Object classes: `uvm_sequence_item`, `uvm_sequence` (covered)
- Class relationships and inheritance (covered)

**Status**: Complete coverage of base class hierarchy

#### 2. Phasing (IEEE 1800.2 Section 5)
**Coverage**: ✅ **Fully Covered**

**Module 3: UVM Basics**
- Build phases: `build_phase()`, `connect_phase()`, `end_of_elaboration_phase()` (covered)
- Run phases: All 12 run phases (pre_reset, reset, post_reset, pre_configure, configure, post_configure, pre_main, main, post_main, pre_shutdown, shutdown, post_shutdown) (covered)
- Cleanup phases: `extract_phase()`, `check_phase()`, `report_phase()`, `final_phase()` (covered)
- Phase synchronization (covered)
- Objection mechanism (covered)

**Status**: Complete coverage of phasing mechanism

#### 3. Reporting (IEEE 1800.2 Section 7)
**Coverage**: ✅ **Fully Covered**

**Module 3: UVM Basics**
- UVM messaging system (covered)
- Severity levels: FATAL, ERROR, WARNING, INFO, DEBUG (covered)
- Verbosity levels: NONE, LOW, MEDIUM, HIGH, FULL, DEBUG (covered)
- Message formatting (covered)
- Reporting usage patterns (covered)

**Status**: Complete coverage of reporting system

#### 4. Configuration (IEEE 1800.2 Section 8)
**Coverage**: ✅ **Fully Covered**

**Module 3: UVM Basics**
- ConfigDB basics (covered)
- Setting and getting configuration (covered)
- Configuration hierarchy (covered)

**Module 5: Advanced UVM Concepts**
- Complex configuration objects (covered)
- Configuration hierarchy patterns (covered)
- Resource database (covered)
- Configuration callbacks (covered)

**Status**: Complete coverage of configuration mechanisms

#### 5. Factory Pattern (IEEE 1800.2 Section 9)
**Coverage**: ✅ **Fully Covered**

**Module 3: UVM Basics**
- Factory pattern basics (covered)
- Factory usage (covered)

**Module 5: Advanced UVM Concepts**
- Factory override mechanisms (implicitly covered through advanced topics)

**Status**: Factory pattern is covered, though advanced override mechanisms could be more explicit

#### 6. Sequences and Sequencers (IEEE 1800.2 Section 10)
**Coverage**: ✅ **Fully Covered**

**Module 4: UVM Components**
- Sequencer implementation (covered)
- Sequence items (`uvm_sequence_item`) (covered)
- Basic sequences (`uvm_sequence`) (covered)
- Sequence execution (covered)
- Driver-sequencer communication (covered)

**Module 5: Advanced UVM Concepts**
- Virtual sequences (covered)
- Sequence libraries (covered)
- Sequence arbitration (covered)
- Layered sequences (covered)
- Virtual sequencers (covered)

**Status**: Complete coverage of sequences and sequencers

#### 7. Register Layer (IEEE 1800.2 Section 11)
**Coverage**: ✅ **Fully Covered**

**Module 3: UVM Basics**
- Register model basics (covered)
- Register blocks, registers, fields (covered)
- Register read/write operations (covered)

**Module 5: Advanced UVM Concepts**
- Register model integration (covered)
- Register sequences (covered)
- Register predictor (covered)
- Backdoor access (covered)

**Status**: Complete coverage of register layer

#### 8. TLM (Transaction-Level Modeling) (IEEE 1800.2 Section 6)
**Coverage**: ✅ **Fully Covered** (Updated)

**Module 4: UVM Components** (Expanded)
- ✅ Analysis ports and exports (covered)
- ✅ `uvm_analysis_port`, `uvm_analysis_export`, `uvm_analysis_imp` (covered)
- ✅ Subscriber pattern (covered)
- ✅ **TLM Interfaces**: All standard TLM interfaces (put, get, peek, transport) now covered
- ✅ **TLM Ports and Exports**: All TLM port types (put_port, get_port, peek_port, transport_port) now covered
- ✅ **TLM FIFOs**: `uvm_tlm_fifo` and related TLM communication mechanisms now covered
- ✅ **TLM Connections**: Detailed TLM connection patterns and best practices now covered

**Status**: Complete coverage of TLM (Transaction-Level Modeling)

#### 9. Miscellaneous Utilities (IEEE 1800.2 Section 12)
**Coverage**: ✅ **Fully Covered** (Updated)

**Module 8: UVM Miscellaneous Utilities** (New Module)
- ✅ **UVM Command Line Processor (CLP)**: Command-line argument parsing (covered)
- ✅ **UVM Comparators**: Built-in comparison utilities (in-order, algorithmic) (covered)
- ✅ **UVM Recorders**: Transaction recording utilities (covered)
- ✅ **UVM Pools**: Object pooling mechanisms (covered)
- ✅ **UVM Queues**: Queue utilities (covered)
- ✅ **UVM String Utilities**: String manipulation utilities (covered)
- ✅ **UVM Math Utilities**: Mathematical utilities (covered)
- ✅ **UVM Random Utilities**: Random number generation utilities (covered)
- ✅ **UVM Primitives**: Primitive utilities and helpers (covered)
- ✅ Utility integration patterns and best practices (covered)

**Status**: Complete coverage of Miscellaneous Utilities

#### 10. Introduction and Scope (IEEE 1800.2 Section 1)
**Coverage**: ✅ **Covered in Module 3**
- UVM introduction and purpose covered
- Scope implicitly understood through module progression

**Status**: Complete coverage

#### 11. Definitions (IEEE 1800.2 Section 3)
**Coverage**: ✅ **Fully Covered** (Updated)

**Glossary Document** (New)
- ✅ Comprehensive glossary of UVM terms
- ✅ pyuvm and cocotb terminology
- ✅ IEEE 1800.2 standard terms
- ✅ Related verification concepts
- ✅ Quick reference for all key terms

**Status**: Complete coverage with dedicated glossary document

---

## Code Syntax and Examples

This section provides detailed code syntax and examples for each IEEE 1800.2 section, showing both SystemVerilog UVM and pyuvm implementations.

### 1. Base Classes (IEEE 1800.2 Section 4)

The base class hierarchy is fundamental to UVM. All UVM classes inherit from either `uvm_object` (for data objects) or `uvm_component` (for hierarchical components). Understanding this distinction is crucial for proper UVM design.

#### SystemVerilog Syntax

**Base Class Hierarchy:**

**uvm_object - Base for all UVM objects (transactions, sequences, configurations):**
```systemverilog
// Basic transaction extending uvm_sequence_item
class my_transaction extends uvm_sequence_item;
    // Class members
    rand bit [7:0] data;
    rand bit [15:0] address;
    rand bit [31:0] timestamp;
    
    // Constructor
    function new(string name = "my_transaction");
        super.new(name);
    endfunction
    
    // Utility methods
    function string convert2string();
        return $sformatf("data=0x%02X, addr=0x%04X, time=%0d", 
                        data, address, timestamp);
    endfunction
    
    // Copy method
    function void do_copy(uvm_object rhs);
        my_transaction rhs_;
        if (!$cast(rhs_, rhs)) begin
            `uvm_error("DO_COPY", "Cast failed")
            return;
        end
        super.do_copy(rhs);
        data = rhs_.data;
        address = rhs_.address;
        timestamp = rhs_.timestamp;
    endfunction
    
    // Compare method
    function bit do_compare(uvm_object rhs, uvm_comparer comparer);
        my_transaction rhs_;
        if (!$cast(rhs_, rhs)) return 0;
        return (data == rhs_.data) && 
               (address == rhs_.address) &&
               (timestamp == rhs_.timestamp);
    endfunction
    
    // Field automation (alternative to manual methods)
    `uvm_object_utils_begin(my_transaction)
        `uvm_field_int(data, UVM_ALL_ON)
        `uvm_field_int(address, UVM_ALL_ON | UVM_HEX)
        `uvm_field_int(timestamp, UVM_ALL_ON | UVM_DEC)
    `uvm_object_utils_end
endclass

// Configuration object extending uvm_object
class my_config extends uvm_object;
    int address_width = 32;
    int data_width = 8;
    bit is_active = 1;
    
    `uvm_object_utils(my_config)
    
    function new(string name = "my_config");
        super.new(name);
    endfunction
endclass
```

**uvm_component - Base for all UVM components (testbench hierarchy):**
```systemverilog
// Driver component
class my_driver extends uvm_driver #(my_transaction);
    // Component constructor - REQUIRES parent
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    // Factory registration
    `uvm_component_utils(my_driver)
    
    // Component hierarchy access
    uvm_component parent;
    uvm_component children[$];
    
    // Phase methods
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        seq_item_port = new("seq_item_port", this);
    endfunction
    
    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        // Access parent: parent = get_parent();
        // Access children: get_children(children);
    endfunction
    
    task run_phase(uvm_phase phase);
        // Driver implementation
    endtask
    
    // Component identification
    function string get_type_name();
        return "my_driver";
    endfunction
    
    function string get_full_name();
        return {get_parent().get_full_name(), ".", get_name()};
    endfunction
endclass

// Environment component demonstrating hierarchy
class my_env extends uvm_env;
    my_agent agent;
    my_scoreboard scoreboard;
    
    `uvm_component_utils(my_env)
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        // Create child components
        agent = my_agent::type_id::create("agent", this);
        scoreboard = my_scoreboard::type_id::create("scoreboard", this);
    endfunction
    
    function void print_topology();
        // Print component hierarchy
        uvm_top.print_topology();
    endfunction
endclass
```

**Key Differences: uvm_object vs uvm_component:**
```systemverilog
// uvm_object characteristics:
// - No parent required
// - Created with new() or factory
// - Can be copied, compared, printed
// - Used for: transactions, sequences, configurations

// uvm_component characteristics:
// - REQUIRES parent in constructor
// - Created only through factory in build_phase
// - Has hierarchical name (full_name)
// - Exists throughout simulation
// - Used for: test, env, agent, driver, monitor, sequencer
```

**Key Syntax Patterns:**
- `extends uvm_object` / `extends uvm_component` - Inheritance
- `super.new(name, parent)` - Parent constructor call (components require parent)
- `super.new(name)` - Object constructor (no parent needed)
- `` `uvm_object_utils_begin/end `` - Field automation macros
- `` `uvm_component_utils `` - Component factory registration
- `function new(string name, uvm_component parent)` - Component constructor signature
- `get_parent()` / `get_children()` - Hierarchy navigation
- `get_full_name()` - Hierarchical name access
- `do_copy()`, `do_compare()`, `convert2string()` - Object utility methods

#### pyuvm Syntax

**Base Class Hierarchy:**

**uvm_object - Base for all UVM objects:**
```python
# Basic transaction extending uvm_sequence_item
class MyTransaction(uvm_sequence_item):
    """Transaction class inheriting from uvm_sequence_item.
    
    Demonstrates uvm_object hierarchy with utility methods.
    """
    
    def __init__(self, name="MyTransaction"):
        super().__init__(name)
        self.data = 0
        self.address = 0
        self.timestamp = 0
    
    def __str__(self):
        """String representation."""
        return (f"{self.get_name()}: data=0x{self.data:02X}, "
                f"addr=0x{self.address:04X}, time={self.timestamp}")
    
    def __eq__(self, other):
        """Equality comparison."""
        if not isinstance(other, MyTransaction):
            return False
        return (self.data == other.data and 
                self.address == other.address and
                self.timestamp == other.timestamp)
    
    def copy(self, rhs=None):
        """Copy method."""
        if rhs is None:
            rhs = MyTransaction()
        rhs.data = self.data
        rhs.address = self.address
        rhs.timestamp = self.timestamp
        return rhs

# Configuration object
class MyConfig(uvm_object):
    """Configuration object for agent settings."""
    
    def __init__(self, name="MyConfig"):
        super().__init__(name)
        self.address_width = 32
        self.data_width = 8
        self.is_active = True
    
    def __str__(self):
        return (f"{self.get_name()}: addr_w={self.address_width}, "
                f"data_w={self.data_width}, active={self.is_active}")
```

**uvm_component - Base for all UVM components:**
```python
# Driver component
class MyDriver(uvm_driver):
    """Driver class inheriting from uvm_driver.
    
    Demonstrates component hierarchy and phase implementation.
    """
    
    def build_phase(self):
        """Build phase - component construction."""
        self.logger.info(f"Building {self.get_name()}")
        self.seq_item_port = uvm_seq_item_pull_port("seq_item_port", self)
    
    def connect_phase(self):
        """Connect phase - component connections."""
        self.logger.info(f"Connecting {self.get_name()}")
        # Access parent: parent = self.get_parent()
        # Access children: children = self.get_children()
    
    async def run_phase(self):
        """Run phase - main execution."""
        self.logger.info(f"Running {self.get_name()}")
        while True:
            item = await self.seq_item_port.get_next_item()
            self.logger.debug(f"Driving transaction: {item}")
            await self.seq_item_port.item_done()
    
    def get_type_name(self):
        """Get component type name."""
        return "MyDriver"
    
    def get_full_name(self):
        """Get hierarchical full name."""
        parent = self.get_parent()
        if parent:
            return f"{parent.get_full_name()}.{self.get_name()}"
        return self.get_name()

# Environment component demonstrating hierarchy
class MyEnv(uvm_env):
    """Environment containing agents and scoreboard."""
    
    def build_phase(self):
        """Build phase - create child components."""
        self.logger.info(f"Building {self.get_name()}")
        self.agent = MyAgent.create("agent", self)
        self.scoreboard = MyScoreboard.create("scoreboard", self)
    
    def connect_phase(self):
        """Connect phase - connect components."""
        self.logger.info(f"Connecting {self.get_name()}")
        # Connect monitor to scoreboard
        self.agent.monitor.ap.connect(self.scoreboard.analysis_export)
    
    def print_topology(self):
        """Print component hierarchy."""
        uvm_root().print_topology()
```

**Complete Example: Object vs Component Usage:**
```python
# Objects: Created directly, no parent needed
txn1 = MyTransaction("txn1")
txn1.data = 0xAA
txn1.address = 0x1000

# Objects: Can be copied
txn2 = txn1.copy()

# Components: Created through factory, require parent
class MyTest(uvm_test):
    def build_phase(self):
        # Components must be created in build_phase with parent
        self.env = MyEnv.create("env", self)  # 'self' is the parent
        
        # Objects can be created anywhere
        config = MyConfig("config")
        config.address_width = 16
```

**Key Syntax Patterns:**
- `class MyClass(uvm_base_class)` - Python inheritance
- `super().__init__(name)` - Parent constructor call
- `self.get_name()` - Component name access
- `self.get_parent()` - Get parent component
- `self.get_children()` - Get child components
- `self.get_full_name()` - Get hierarchical full name
- `async def run_phase(self)` - Async phase methods in pyuvm
- `__str__()` - String representation (Python equivalent of convert2string)
- `__eq__()` - Equality comparison (Python equivalent of do_compare)
- `copy()` - Object copying (Python equivalent of do_copy)
- `Class.create("name", parent)` - Factory creation method

---

### 2. Phasing (IEEE 1800.2 Section 5)

UVM phasing provides a structured execution model for testbench components. Phases execute in a specific order and can be synchronous (functions) or asynchronous (tasks). The phase mechanism ensures proper initialization, execution, and cleanup of the testbench.

#### Phase Categories

1. **Build Phases** (Synchronous, bottom-up): Component construction
2. **Run Phases** (Asynchronous, parallel): Test execution
3. **Cleanup Phases** (Synchronous, bottom-up): Result extraction and reporting

#### SystemVerilog Syntax

**Complete Phase Implementation:**
```systemverilog
class my_component extends uvm_component;
    `uvm_component_utils(my_component)
    
    // ============================================
    // BUILD PHASES (Synchronous, bottom-up order)
    // ============================================
    
    // 1. build_phase - Create child components
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        `uvm_info("BUILD", "Building component", UVM_MEDIUM)
        // Create child components using factory
        child = my_child::type_id::create("child", this);
        // Get configuration from ConfigDB
        if (!uvm_config_db#(int)::get(this, "", "config_value", cfg_val)) begin
            `uvm_warning("CFG", "Config not found, using default")
            cfg_val = 32;
        end
    endfunction
    
    // 2. connect_phase - Connect components
    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        `uvm_info("CONNECT", "Connecting component", UVM_MEDIUM)
        // Connect TLM ports/exports
        driver.seq_item_port.connect(sequencer.seq_item_export);
        monitor.ap.connect(scoreboard.analysis_export);
    endfunction
    
    // 3. end_of_elaboration_phase - Final setup
    function void end_of_elaboration_phase(uvm_phase phase);
        super.end_of_elaboration_phase(phase);
        `uvm_info("ELAB", "Elaboration complete", UVM_MEDIUM)
        // Print topology, validate connections
        print_topology();
    endfunction
    
    // ============================================
    // RUN PHASES (Asynchronous, parallel execution)
    // ============================================
    
    // Pre-reset phase
    task pre_reset_phase(uvm_phase phase);
        phase.raise_objection(this, "Pre-reset activities");
        `uvm_info("PRE_RESET", "Pre-reset phase", UVM_MEDIUM)
        // Pre-reset initialization
        #10ns;
        phase.drop_objection(this);
    endtask
    
    // Reset phase
    task reset_phase(uvm_phase phase);
        phase.raise_objection(this, "Reset sequence");
        `uvm_info("RESET", "Reset phase", UVM_MEDIUM)
        // Drive reset signals
        dut.rst_n <= 0;
        #100ns;
        dut.rst_n <= 1;
        #10ns;
        phase.drop_objection(this);
    endtask
    
    // Post-reset phase
    task post_reset_phase(uvm_phase phase);
        phase.raise_objection(this, "Post-reset");
        `uvm_info("POST_RESET", "Post-reset phase", UVM_MEDIUM)
        #10ns;
        phase.drop_objection(this);
    endtask
    
    // Main phase - primary test execution
    task main_phase(uvm_phase phase);
        phase.raise_objection(this, "Main test");
        `uvm_info("MAIN", "Main phase - running test", UVM_MEDIUM)
        
        // Start sequences
        fork
            begin
                my_sequence seq;
                seq = my_sequence::type_id::create("seq");
                seq.start(sequencer);
            end
        join_none
        
        // Wait for test completion
        wait_for_test_completion();
        
        phase.drop_objection(this, "Test complete");
    endtask
    
    // ============================================
    // CLEANUP PHASES (Synchronous, bottom-up)
    // ============================================
    
    // Extract phase - collect results
    function void extract_phase(uvm_phase phase);
        `uvm_info("EXTRACT", "Extracting results", UVM_MEDIUM)
        // Extract coverage, statistics, etc.
        extract_coverage();
        extract_statistics();
    endfunction
    
    // Check phase - final verification
    function void check_phase(uvm_phase phase);
        `uvm_info("CHECK", "Checking results", UVM_MEDIUM)
        // Final checks, assertions
        if (error_count > 0) begin
            `uvm_error("CHECK", $sformatf("Found %0d errors", error_count))
        end
    endfunction
    
    // Report phase - generate reports
    function void report_phase(uvm_phase phase);
        `uvm_info("REPORT", "Generating report", UVM_MEDIUM)
        // Print summary, coverage reports
        print_summary();
    endfunction
    
    // Final phase - last cleanup
    function void final_phase(uvm_phase phase);
        `uvm_info("FINAL", "Final cleanup", UVM_MEDIUM)
        // Final cleanup if needed
    endfunction
endclass
```

**Objection Mechanism - Detailed Usage:**
```systemverilog
// Basic objection usage
task run_phase(uvm_phase phase);
    phase.raise_objection(this, "Starting test");
    // Test logic here
    phase.drop_objection(this, "Test complete");
endtask

// Multiple objections (counted)
task main_phase(uvm_phase phase);
    phase.raise_objection(this, "Starting sequence 1");
    phase.raise_objection(this, "Starting sequence 2");
    // Both sequences running
    phase.drop_objection(this, "Sequence 1 complete");
    phase.drop_objection(this, "Sequence 2 complete");
endtask

// Conditional objections
task main_phase(uvm_phase phase);
    if (is_active) begin
        phase.raise_objection(this, "Active mode");
        // Active test logic
        phase.drop_objection(this);
    end
endtask

// Timeout with objections
task main_phase(uvm_phase phase);
    phase.raise_objection(this);
    fork
        begin
            // Test logic
            #1000ns;
            phase.drop_objection(this);
        end
        begin
            #2000ns;
            `uvm_error("TIMEOUT", "Test timed out")
            phase.drop_objection(this);
        end
    join
endtask
```

**Phase Jumping and Synchronization:**
```systemverilog
// Jump to a specific phase
task main_phase(uvm_phase phase);
    phase.raise_objection(this);
    // Jump to shutdown phase
    phase.jump(uvm_shutdown_phase::get());
    phase.drop_objection(this);
endtask

// Phase synchronization
task main_phase(uvm_phase phase);
    phase.raise_objection(this);
    // Wait for specific condition
    wait(dut.ready == 1);
    phase.drop_objection(this);
endtask
```

**Key Syntax Patterns:**
- `function void <phase>_phase(uvm_phase phase)` - Synchronous phases (build, connect, extract, check, report, final)
- `task <phase>_phase(uvm_phase phase)` - Asynchronous phases (all run phases)
- `super.<phase>_phase(phase)` - Always call super for proper phase execution
- `phase.raise_objection(this, "description")` - Raise objection with description
- `phase.drop_objection(this, "description")` - Drop objection
- `phase.jump(target_phase)` - Jump to specific phase
- Build phases execute bottom-up (children before parents)
- Run phases execute in parallel across all components
- Cleanup phases execute bottom-up (children before parents)

#### pyuvm Syntax

**Complete Phase Implementation:**
```python
class PhasesComponent(uvm_component):
    """Component demonstrating all UVM phases with detailed examples."""
    
    # ============================================
    # BUILD PHASES (Synchronous, bottom-up order)
    # ============================================
    
    def build_phase(self):
        """Build phase - component construction.
        
        Executes bottom-up: children before parents.
        Create child components and get configuration.
        """
        self.logger.info(f"[BUILD] {self.get_name()}: Building component")
        
        # Create child components using factory
        self.child = MyChild.create("child", self)
        
        # Get configuration from ConfigDB
        config_value = 32
        success = ConfigDB().get(None, "", "config_value", config_value)
        if not success:
            self.logger.warning("Config not found, using default")
        else:
            self.logger.info(f"Got config_value: {config_value}")
    
    def connect_phase(self):
        """Connect phase - component connections.
        
        Connect TLM ports/exports and establish communication paths.
        """
        self.logger.info(f"[CONNECT] {self.get_name()}: Connecting component")
        
        # Connect TLM ports
        self.driver.seq_item_port.connect(self.sequencer.seq_item_export)
        self.monitor.ap.connect(self.scoreboard.analysis_export)
    
    def end_of_elaboration_phase(self):
        """End of elaboration phase - final setup.
        
        Validate connections, print topology, final configuration.
        """
        self.logger.info(f"[END_OF_ELAB] {self.get_name()}: Elaboration complete")
        
        # Print component hierarchy
        uvm_root().print_topology()
    
    # ============================================
    # RUN PHASES (Asynchronous, parallel execution)
    # ============================================
    
    async def pre_reset_phase(self):
        """Pre-reset phase - before reset sequence."""
        self.logger.info(f"[PRE_RESET] {self.get_name()}: Pre-reset phase")
        await Timer(10, unit="ns")
    
    async def reset_phase(self):
        """Reset phase - reset sequence.
        
        Drive reset signals and wait for reset completion.
        """
        self.logger.info(f"[RESET] {self.get_name()}: Reset phase")
        
        # Drive reset (example with cocotb)
        # await cocotb.triggers.Timer(100, units="ns")
        # dut.rst_n.value = 0
        # await cocotb.triggers.Timer(100, units="ns")
        # dut.rst_n.value = 1
        # await cocotb.triggers.Timer(10, units="ns")
        
        await Timer(20, unit="ns")
    
    async def post_reset_phase(self):
        """Post-reset phase - after reset."""
        self.logger.info(f"[POST_RESET] {self.get_name()}: Post-reset phase")
        await Timer(10, unit="ns")
    
    async def pre_configure_phase(self):
        """Pre-configure phase - before configuration."""
        self.logger.info(f"[PRE_CONFIGURE] {self.get_name()}: Pre-configure phase")
        await Timer(10, unit="ns")
    
    async def configure_phase(self):
        """Configure phase - configuration sequence."""
        self.logger.info(f"[CONFIGURE] {self.get_name()}: Configure phase")
        await Timer(10, unit="ns")
    
    async def post_configure_phase(self):
        """Post-configure phase - after configuration."""
        self.logger.info(f"[POST_CONFIGURE] {self.get_name()}: Post-configure phase")
        await Timer(10, unit="ns")
    
    async def pre_main_phase(self):
        """Pre-main phase - before main test."""
        self.logger.info(f"[PRE_MAIN] {self.get_name()}: Pre-main phase")
        await Timer(10, unit="ns")
    
    async def main_phase(self):
        """Main phase - main test execution.
        
        Primary test logic executes here. Use objections to control
        when the phase can complete.
        """
        self.logger.info(f"[MAIN] {self.get_name()}: Main phase - running test")
        
        # Start sequences
        seq = MySequence.create("seq")
        await seq.start(self.sequencer)
        
        # Wait for test completion
        await self.wait_for_test_completion()
    
    async def post_main_phase(self):
        """Post-main phase - after main test."""
        self.logger.info(f"[POST_MAIN] {self.get_name()}: Post-main phase")
        await Timer(10, unit="ns")
    
    async def pre_shutdown_phase(self):
        """Pre-shutdown phase - before shutdown."""
        self.logger.info(f"[PRE_SHUTDOWN] {self.get_name()}: Pre-shutdown phase")
        await Timer(10, unit="ns")
    
    async def shutdown_phase(self):
        """Shutdown phase - shutdown sequence."""
        self.logger.info(f"[SHUTDOWN] {self.get_name()}: Shutdown phase")
        await Timer(10, unit="ns")
    
    async def post_shutdown_phase(self):
        """Post-shutdown phase - after shutdown."""
        self.logger.info(f"[POST_SHUTDOWN] {self.get_name()}: Post-shutdown phase")
        await Timer(10, unit="ns")
    
    # ============================================
    # CLEANUP PHASES (Synchronous, bottom-up)
    # ============================================
    
    def extract_phase(self):
        """Extract phase - extract results.
        
        Collect coverage data, statistics, and other results.
        """
        self.logger.info(f"[EXTRACT] {self.get_name()}: Extracting results")
        # Extract coverage, statistics, etc.
        self.extract_coverage()
        self.extract_statistics()
    
    def check_phase(self):
        """Check phase - final verification.
        
        Perform final checks and validate test results.
        """
        self.logger.info(f"[CHECK] {self.get_name()}: Checking results")
        if self.error_count > 0:
            self.logger.error(f"Found {self.error_count} errors")
    
    def report_phase(self):
        """Report phase - generate reports.
        
        Print summary, coverage reports, and test results.
        """
        self.logger.info(f"[REPORT] {self.get_name()}: Generating report")
        self.print_summary()
    
    def final_phase(self):
        """Final phase - last cleanup."""
        self.logger.info(f"[FINAL] {self.get_name()}: Final cleanup")
```

**Objection Mechanism - Detailed Usage:**
```python
# Basic objection usage
async def run_phase(self):
    """Run phase with objections."""
    self.raise_objection()
    # Test logic here
    await Timer(100, unit="ns")
    self.drop_objection()

# Multiple objections (counted)
async def main_phase(self):
    """Multiple objections example."""
    self.raise_objection("Starting sequence 1")
    self.raise_objection("Starting sequence 2")
    # Both sequences running
    await asyncio.gather(
        self.run_sequence1(),
        self.run_sequence2()
    )
    self.drop_objection("Sequence 1 complete")
    self.drop_objection("Sequence 2 complete")

# Conditional objections
async def main_phase(self):
    """Conditional objections."""
    if self.is_active:
        self.raise_objection("Active mode")
        # Active test logic
        await self.run_active_test()
        self.drop_objection()

# Timeout with objections
async def main_phase(self):
    """Timeout handling with objections."""
    self.raise_objection()
    try:
        await asyncio.wait_for(
            self.run_test(),
            timeout=2000  # nanoseconds
        )
    except asyncio.TimeoutError:
        self.logger.error("Test timed out")
    finally:
        self.drop_objection()
```

**Phase Synchronization Patterns:**
```python
# Wait for condition
async def main_phase(self):
    """Wait for specific condition."""
    self.raise_objection()
    while not self.ready:
        await Timer(10, unit="ns")
    self.drop_objection()

# Coordinate multiple components
async def main_phase(self):
    """Coordinate multiple components."""
    self.raise_objection()
    # Start multiple tasks
    tasks = [
        self.driver.run(),
        self.monitor.run(),
        self.scoreboard.run()
    ]
    await asyncio.gather(*tasks)
    self.drop_objection()
```

**Key Syntax Patterns:**
- `def <phase>_phase(self)` - Synchronous phases (build, connect, extract, check, report, final)
- `async def <phase>_phase(self)` - Asynchronous phases (all run phases)
- `self.raise_objection(description)` - Raise objection with optional description
- `self.drop_objection(description)` - Drop objection
- `await Timer(delay, unit="ns")` - Async delay in pyuvm
- `await asyncio.gather(*tasks)` - Run multiple async tasks in parallel
- `await asyncio.wait_for(coro, timeout)` - Timeout handling
- Build phases execute bottom-up (children before parents)
- Run phases execute in parallel across all components
- Cleanup phases execute bottom-up (children before parents)
- Always use `async def` for run phases in pyuvm
- Use `await` for all async operations in run phases

---

### 3. Reporting (IEEE 1800.2 Section 7)

UVM provides a comprehensive reporting system with severity levels, verbosity control, and flexible message handling. The reporting system helps with debugging, monitoring, and controlling test output.

#### Severity Levels

1. **UVM_INFO** - Informational messages (can be filtered by verbosity)
2. **UVM_WARNING** - Warning messages (potential issues)
3. **UVM_ERROR** - Error messages (test failures)
4. **UVM_FATAL** - Fatal messages (simulation stops)

#### Verbosity Levels

1. **UVM_NONE** - No messages
2. **UVM_LOW** - Essential messages only
3. **UVM_MEDIUM** - Standard messages (default)
4. **UVM_HIGH** - Detailed messages
5. **UVM_FULL** - Very detailed messages
6. **UVM_DEBUG** - Debug messages

#### SystemVerilog Syntax

**Message Macros - Complete Usage:**
```systemverilog
class my_component extends uvm_component;
    `uvm_component_utils(my_component)
    
    task run_phase(uvm_phase phase);
        // ============================================
        // Severity Levels
        // ============================================
        
        // INFO - Informational messages
        `uvm_info("DRIVER", "Starting driver", UVM_LOW)
        `uvm_info("DRIVER", "Transaction details", UVM_MEDIUM)
        `uvm_info("DRIVER", "Detailed debug info", UVM_DEBUG)
        
        // WARNING - Potential issues
        `uvm_warning("DRIVER", "Unexpected transaction format")
        `uvm_warning("DRIVER", "Timeout occurred, retrying")
        
        // ERROR - Test failures
        `uvm_error("DRIVER", "Transaction failed")
        `uvm_error("DRIVER", $sformatf("Expected %0d, got %0d", expected, actual))
        
        // FATAL - Simulation stops
        `uvm_fatal("DRIVER", "Critical failure, stopping simulation")
        
        // ============================================
        // Verbosity Control
        // ============================================
        
        `uvm_info("TAG", "Low verbosity - always shown", UVM_LOW)
        `uvm_info("TAG", "Medium verbosity - default", UVM_MEDIUM)
        `uvm_info("TAG", "High verbosity - detailed", UVM_HIGH)
        `uvm_info("TAG", "Full verbosity - very detailed", UVM_FULL)
        `uvm_info("TAG", "Debug verbosity - debug only", UVM_DEBUG)
        
        // ============================================
        // Formatted Messages
        // ============================================
        
        bit [7:0] data = 8'hAB;
        bit [15:0] addr = 16'h1000;
        int count = 42;
        
        `uvm_info("TAG", $sformatf("data=0x%02X, addr=0x%04X", data, addr), UVM_LOW)
        `uvm_info("TAG", $sformatf("Count: %0d", count), UVM_LOW)
        `uvm_info("TAG", $sformatf("Time: %0t", $time), UVM_MEDIUM)
        
        // ============================================
        // Context Information
        // ============================================
        
        `uvm_info("TAG", $sformatf("Component: %s", get_full_name()), UVM_LOW)
        `uvm_info("TAG", $sformatf("Type: %s", get_type_name()), UVM_LOW)
    endtask
endclass
```

**Reporting Configuration - Advanced:**
```systemverilog
// Global verbosity setting
initial begin
    uvm_top.set_report_verbosity_level(UVM_HIGH);
end

// Component-specific verbosity
initial begin
    uvm_top.set_report_verbosity_level_hier(UVM_FULL);
end

// Severity actions (what to do with messages)
initial begin
    // Display and log errors
    uvm_top.set_report_severity_action(UVM_ERROR, UVM_DISPLAY | UVM_LOG);
    
    // Count warnings but don't display
    uvm_top.set_report_severity_action(UVM_WARNING, UVM_COUNT);
    
    // Stop on fatal
    uvm_top.set_report_severity_action(UVM_FATAL, UVM_DISPLAY | UVM_EXIT);
end

// ID-based verbosity (tag-specific)
initial begin
    uvm_top.set_report_id_verbosity("DRIVER", UVM_FULL);
    uvm_top.set_report_id_verbosity("MONITOR", UVM_HIGH);
    uvm_top.set_report_id_verbosity("SCOREBOARD", UVM_DEBUG);
end

// File-based reporting
initial begin
    uvm_top.set_report_severity_file(UVM_ERROR, "error.log");
    uvm_top.set_report_severity_file(UVM_WARNING, "warning.log");
end

// Message count limits
initial begin
    uvm_top.set_report_max_quit_count(10);  // Stop after 10 errors
end
```

**Custom Report Handlers:**
```systemverilog
class my_report_handler extends uvm_report_handler;
    function void report(uvm_severity severity, string name, 
                        string id, string message, 
                        string filename, int line,
                        string context_name, 
                        uvm_report_object client);
        // Custom reporting logic
        if (severity == UVM_ERROR) begin
            $display("CUSTOM ERROR: %s", message);
        end
        super.report(severity, name, id, message, filename, line, 
                    context_name, client);
    endfunction
endclass

// Use custom handler
initial begin
    my_report_handler handler = new();
    uvm_top.set_report_handler(handler);
end
```

**Key Syntax Patterns:**
- `` `uvm_info("TAG", "message", verbosity) `` - Info message macro
- `` `uvm_warning("TAG", "message") `` - Warning macro
- `` `uvm_error("TAG", "message") `` - Error macro
- `` `uvm_fatal("TAG", "message") `` - Fatal macro (stops simulation)
- `UVM_LOW/MEDIUM/HIGH/FULL/DEBUG` - Verbosity constants
- `$sformatf()` - String formatting for messages
- `uvm_top.set_report_verbosity_level()` - Set global verbosity
- `uvm_top.set_report_id_verbosity()` - Set tag-specific verbosity
- `uvm_top.set_report_severity_action()` - Configure severity actions
- `uvm_top.set_report_max_quit_count()` - Set error limit

#### pyuvm Syntax

**Message Methods - Complete Usage:**
```python
class ReportingTest(uvm_test):
    """Test demonstrating UVM reporting system with all features."""
    
    async def run_phase(self):
        """Run phase - demonstrate comprehensive reporting."""
        self.raise_objection()
        
        # ============================================
        # Severity Levels
        # ============================================
        
        # INFO - Informational messages
        self.logger.info("Starting test execution")
        self.logger.info("Transaction processed successfully")
        
        # WARNING - Potential issues
        self.logger.warning("Unexpected transaction format detected")
        self.logger.warning("Timeout occurred, retrying operation")
        
        # ERROR - Test failures
        self.logger.error("Transaction validation failed")
        self.logger.error(f"Expected {expected}, got {actual}")
        
        # FATAL - Critical failures (stops simulation)
        self.logger.fatal("Critical system failure, stopping simulation")
        
        # ============================================
        # Formatted Messages
        # ============================================
        
        data = 0xAB
        address = 0x1000
        count = 42
        
        # Using f-strings (recommended)
        self.logger.info(f"Formatted message: data=0x{data:02X}, addr=0x{address:04X}")
        self.logger.info(f"Count: {count}, Percentage: {count/100*100:.1f}%")
        
        # Using format() method
        self.logger.info("Data: 0x{:02X}, Addr: 0x{:04X}".format(data, address))
        
        # Multi-line messages
        self.logger.info(
            f"Transaction details:\n"
            f"  Data: 0x{data:02X}\n"
            f"  Address: 0x{address:04X}\n"
            f"  Count: {count}"
        )
        
        # ============================================
        # Context Information
        # ============================================
        
        self.logger.info(f"Component name: {self.get_name()}")
        self.logger.info(f"Component type: {self.get_type_name()}")
        self.logger.info(f"Full name: {self.get_full_name()}")
        
        # ============================================
        # Conditional Logging
        # ============================================
        
        if self.debug_mode:
            self.logger.info("Debug mode enabled")
            self.logger.info(f"Internal state: {self.internal_state}")
        
        # ============================================
        # Error Context
        # ============================================
        
        try:
            result = self.risky_operation()
        except Exception as e:
            self.logger.error(f"Operation failed: {e}")
            self.logger.error(f"Context: {self.get_full_name()}")
            raise
        
        self.drop_objection()
    
    def check_phase(self):
        """Check phase - demonstrate error reporting."""
        if self.error_count > 0:
            self.logger.error(f"Test failed with {self.error_count} errors")
            for i, error in enumerate(self.errors):
                self.logger.error(f"Error {i+1}: {error}")
        else:
            self.logger.info("All checks passed")
    
    def report_phase(self):
        """Report phase - demonstrate summary reporting."""
        self.logger.info("=" * 60)
        self.logger.info("TEST SUMMARY")
        self.logger.info("=" * 60)
        self.logger.info(f"Total transactions: {self.total_transactions}")
        self.logger.info(f"Passed: {self.passed_count}")
        self.logger.info(f"Failed: {self.failed_count}")
        self.logger.info(f"Coverage: {self.coverage_percentage:.1f}%")
        self.logger.info("=" * 60)
```

**Reporting Configuration:**
```python
# Verbosity control (typically set in test or command line)
class VerbosityTest(uvm_test):
    """Test demonstrating verbosity control."""
    
    async def build_phase(self):
        """Set verbosity levels."""
        # Set global verbosity
        uvm_root().set_report_verbosity_level(uvm_verbosity.UVM_HIGH)
        
        # Set component-specific verbosity
        uvm_root().set_report_verbosity_level_hier(uvm_verbosity.UVM_FULL)
        
        # Set ID-specific verbosity
        uvm_root().set_report_id_verbosity("DRIVER", uvm_verbosity.UVM_DEBUG)
        uvm_root().set_report_id_verbosity("MONITOR", uvm_verbosity.UVM_HIGH)
    
    async def run_phase(self):
        """Demonstrate different verbosity levels."""
        self.raise_objection()
        
        # These messages will be filtered based on verbosity settings
        self.logger.info("Low verbosity message")  # Always shown
        self.logger.info("Medium verbosity message")  # Default
        self.logger.info("High verbosity message")  # Only if UVM_HIGH+
        self.logger.info("Debug message")  # Only if UVM_DEBUG
        
        self.drop_objection()
```

**Key Syntax Patterns:**
- `self.logger.info(message)` - Info message
- `self.logger.warning(message)` - Warning message
- `self.logger.error(message)` - Error message
- `self.logger.fatal(message)` - Fatal message (stops simulation)
- `f"formatted {variable}"` - Python f-string formatting (recommended)
- `"{:02X}".format(value)` - Alternative format method
- `uvm_root().set_report_verbosity_level()` - Set global verbosity
- `uvm_root().set_report_id_verbosity()` - Set tag-specific verbosity
- Messages automatically include component context
- Use f-strings for formatted messages (Python 3.6+)
- Logger is automatically available in all components

---

### 4. Configuration (IEEE 1800.2 Section 8)

UVM's configuration mechanism allows flexible parameterization of testbench components. The `uvm_config_db` provides a centralized database for storing and retrieving configuration values using hierarchical paths.

#### Configuration Concepts

1. **Context** - Where the configuration is set/get (component hierarchy)
2. **Path** - Hierarchical path to target component (`""`, `"*"`, or specific path)
3. **Name** - Configuration name (identifier)
4. **Value** - Configuration value (scalar or object)

#### SystemVerilog Syntax

**ConfigDB Usage - Comprehensive Examples:**
```systemverilog
// Configuration object
class agent_config extends uvm_object;
    int address_width = 32;
    int data_width = 8;
    bit is_active = 1;
    bit has_coverage = 0;
    
    `uvm_object_utils(agent_config)
    
    function new(string name = "agent_config");
        super.new(name);
    endfunction
endclass

// Environment setting configuration
class my_env extends uvm_env;
    `uvm_component_utils(my_env)
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // ============================================
        // Setting Scalar Configuration
        // ============================================
        
        // Set for all components (wildcard)
        uvm_config_db#(int)::set(this, "*", "address_width", 32);
        uvm_config_db#(int)::set(this, "*", "data_width", 8);
        uvm_config_db#(bit)::set(this, "*", "is_active", 1);
        
        // Set for specific component path
        uvm_config_db#(int)::set(this, "agent.driver", "timeout", 1000);
        
        // Set for current component only
        uvm_config_db#(string)::set(this, "", "test_name", "basic_test");
        
        // ============================================
        // Setting Object Configuration
        // ============================================
        
        // Create and configure object
        agent_config cfg = agent_config::type_id::create("cfg");
        cfg.address_width = 32;
        cfg.data_width = 8;
        cfg.is_active = 1;
        cfg.has_coverage = 1;
        
        // Set object configuration
        uvm_config_db#(agent_config)::set(this, "*", "agent_config", cfg);
        
        // Set for specific agent
        agent_config cfg2 = agent_config::type_id::create("cfg2");
        cfg2.address_width = 16;
        uvm_config_db#(agent_config)::set(this, "agent2", "agent_config", cfg2);
        
        // ============================================
        // Create Components (they will get config)
        // ============================================
        
        agent = my_agent::type_id::create("agent", this);
        agent2 = my_agent::type_id::create("agent2", this);
    endfunction
endclass

// Agent getting configuration
class my_agent extends uvm_agent;
    `uvm_component_utils(my_agent)
    
    // Configuration variables
    int address_width;
    int data_width;
    bit is_active;
    agent_config cfg;
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
        // ============================================
        // Getting Scalar Configuration
        // ============================================
        
        // Get with default value
        address_width = 16;  // Default
        if (!uvm_config_db#(int)::get(this, "", "address_width", address_width)) begin
            `uvm_warning("CFG", "address_width not found, using default")
        end else begin
            `uvm_info("CFG", $sformatf("Got address_width: %0d", address_width), UVM_MEDIUM)
        end
        
        // Get data_width
        data_width = 8;  // Default
        uvm_config_db#(int)::get(this, "", "data_width", data_width);
        
        // Get is_active
        is_active = 0;  // Default
        uvm_config_db#(bit)::get(this, "", "is_active", is_active);
        
        // ============================================
        // Getting Object Configuration
        // ============================================
        
        // Get configuration object
        if (!uvm_config_db#(agent_config)::get(this, "", "agent_config", cfg)) begin
            `uvm_warning("CFG", "agent_config not found, creating default")
            cfg = agent_config::type_id::create("cfg");
        end else begin
            `uvm_info("CFG", "Got agent_config from ConfigDB", UVM_MEDIUM)
        end
        
        // Use configuration
        if (cfg.is_active) begin
            driver = my_driver::type_id::create("driver", this);
            sequencer = my_sequencer::type_id::create("sequencer", this);
        end
        monitor = my_monitor::type_id::create("monitor", this);
    endfunction
endclass
```

**Configuration Hierarchy and Path Matching:**
```systemverilog
// Configuration path matching rules:
// 1. Exact path match: "agent.driver"
// 2. Wildcard match: "*" matches all components
// 3. Empty path: "" matches current component
// 4. Hierarchical: More specific paths override general ones

// Example: Setting configuration at different levels
class my_test extends uvm_test;
    function void build_phase(uvm_phase phase);
        // Global setting
        uvm_config_db#(int)::set(this, "*", "global_param", 100);
        
        // Environment-specific
        uvm_config_db#(int)::set(this, "env", "env_param", 200);
        
        // Agent-specific
        uvm_config_db#(int)::set(this, "env.agent", "agent_param", 300);
        
        // Driver-specific
        uvm_config_db#(int)::set(this, "env.agent.driver", "driver_param", 400);
    endfunction
endclass
```

**Configuration from Command Line:**
```systemverilog
// In test or top module
initial begin
    string test_name;
    int num_transactions;
    
    // Get from command line plusargs
    if ($value$plusargs("TESTNAME=%s", test_name)) begin
        uvm_config_db#(string)::set(null, "*", "test_name", test_name);
    end
    
    if ($value$plusargs("NUM_TRANS=%d", num_transactions)) begin
        uvm_config_db#(int)::set(null, "*", "num_transactions", num_transactions);
    end
end
```

**Key Syntax Patterns:**
- `uvm_config_db#(type)::set(context, path, name, value)` - Set config
- `uvm_config_db#(type)::get(context, path, name, var)` - Get config
- `this` - Current component context
- `null` - Global context (top-level)
- `"*"` - Wildcard path (matches all components)
- `""` - Empty path (matches current component)
- `"component.path"` - Specific hierarchical path
- Configuration is set before `build_phase()` and retrieved during `build_phase()`
- More specific paths override general ones
- Objects are passed by reference (shared, not copied)

#### pyuvm Syntax

**ConfigDB Usage:**
```python
class ConfigurableEnv(uvm_env):
    """Environment that sets configuration in ConfigDB."""
    
    def build_phase(self):
        """Build phase - set configuration in ConfigDB."""
        # Create and set configuration object
        agent_config = AgentConfig("agent_config")
        agent_config.active = True
        agent_config.has_coverage = True
        agent_config.address_width = 16
        
        ConfigDB().set(None, "", "agent_config", agent_config)
        
        # Set scalar configuration
        ConfigDB().set(None, "", "address_width", 16)
        ConfigDB().set(None, "", "data_width", 8)
        
        # Create agent (will get config from ConfigDB)
        self.agent = ConfigurableAgent.create("agent", self)

class ConfigurableAgent(uvm_agent):
    """Agent that uses ConfigDB for configuration."""
    
    def build_phase(self):
        """Build phase - get configuration from ConfigDB."""
        # Get configuration from ConfigDB
        config = None
        success = ConfigDB().get(None, "", "agent_config", config)
        
        if success and config is not None:
            self.active = config.active
            self.has_coverage = config.has_coverage
        else:
            self.logger.warning("No config found, using defaults")
            self.active = True
        
        # Get scalar configuration
        address_width = 32
        success = ConfigDB().get(None, "", "address_width", address_width)
        if success:
            self.logger.info(f"Got address_width: {address_width}")
```

**Key Syntax Patterns:**
- `ConfigDB().set(context, path, name, value)` - Set config
- `ConfigDB().get(context, path, name, var)` - Get config
- `None` - Global context in pyuvm
- `""` - Empty path (all components)

---

### 5. Factory Pattern (IEEE 1800.2 Section 9)

#### SystemVerilog Syntax

**Factory Registration and Usage:**
```systemverilog
// Object factory registration
class my_transaction extends uvm_sequence_item;
    `uvm_object_utils(my_transaction)
    
    function new(string name = "my_transaction");
        super.new(name);
    endfunction
endclass

// Component factory registration
class my_driver extends uvm_driver #(my_transaction);
    `uvm_component_utils(my_driver)
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
endclass

// Factory creation
class my_agent extends uvm_agent;
    my_driver driver;
    
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        // Factory creates component
        driver = my_driver::type_id::create("driver", this);
    endfunction
endclass

// Factory override
class my_test extends uvm_test;
    function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        // Set type override
        my_driver::type_id::set_type_override(extended_driver::get_type());
        // Set instance override
        my_driver::type_id::set_inst_override(extended_driver::get_type(), "env.agent.driver");
    endfunction
endclass
```

**Key Syntax Patterns:**
- `` `uvm_object_utils(class_name) `` - Object factory registration
- `` `uvm_component_utils(class_name) `` - Component factory registration
- `class_name::type_id::create("name", parent)` - Factory creation
- `class_name::type_id::set_type_override(new_type)` - Type override
- `class_name::type_id::set_inst_override(new_type, "path")` - Instance override

#### pyuvm Syntax

**Factory Registration and Usage:**
```python
# Object creation (automatic registration in pyuvm)
class BaseTransaction(uvm_sequence_item):
    """Base transaction class."""
    
    def __init__(self, name="BaseTransaction"):
        super().__init__(name)
        self.data = 0

# Component factory creation
class FactoryAgent(uvm_agent):
    """Agent using factory for component creation."""
    
    def build_phase(self):
        """Build phase - use factory to create components."""
        # Factory creates components
        self.driver = uvm_factory().create_component_by_type(
            BaseDriver, "driver", self
        )

# Factory override
class FactoryOverrideTest(uvm_test):
    """Test demonstrating factory overrides."""
    
    async def build_phase(self):
        """Build phase - demonstrate factory override."""
        # Set factory override
        uvm_factory().set_type_override(BaseDriver, ExtendedDriver)
        
        # Create environment (should use ExtendedDriver due to override)
        self.env = FactoryAgent.create("env", self)
```

**Key Syntax Patterns:**
- `uvm_factory().create_component_by_type(type, name, parent)` - Factory creation
- `uvm_factory().set_type_override(old_type, new_type)` - Type override
- `Class.create("name", parent)` - Convenience factory method

---

### 6. Sequences and Sequencers (IEEE 1800.2 Section 10)

Sequences and sequencers form the core of UVM's stimulus generation mechanism. Sequences generate transactions, sequencers arbitrate between sequences, and drivers consume transactions.

#### Key Concepts

1. **Sequence Item** - Data structure representing a transaction
2. **Sequence** - Generates and sends sequence items to sequencer
3. **Sequencer** - Arbitrates between sequences and provides items to driver
4. **Driver** - Consumes items from sequencer and drives DUT

#### SystemVerilog Syntax

**Sequence Item - Enhanced Example:**
```systemverilog
class my_sequence_item extends uvm_sequence_item;
    // Transaction fields
    rand bit [7:0] data;
    rand bit [15:0] address;
    rand bit [31:0] timestamp;
    rand bit write;
    rand int delay;
    
    // Constraints for randomization
    constraint valid_address {
        address inside {[0:1023]};
    }
    
    constraint valid_delay {
        delay inside {[1:10]};
    }
    
    constraint write_data {
        if (write) {
            data != 0;
        }
    }
    
    `uvm_object_utils(my_sequence_item)
    
    function new(string name = "my_sequence_item");
        super.new(name);
    endfunction
    
    // Pre/post randomization hooks
    function void pre_randomize();
        `uvm_info("SEQ_ITEM", "Pre-randomize", UVM_DEBUG)
    endfunction
    
    function void post_randomize();
        `uvm_info("SEQ_ITEM", "Post-randomize", UVM_DEBUG)
    endfunction
    
    // Convert to string
    function string convert2string();
        return $sformatf("data=0x%02X, addr=0x%04X, write=%0d", 
                       data, address, write);
    endfunction
endclass
```

**Sequence - Multiple Patterns:**
```systemverilog
// Basic sequence
class my_sequence extends uvm_sequence #(my_sequence_item);
    `uvm_object_utils(my_sequence)
    
    // Sequence variables
    int num_items = 10;
    bit [15:0] base_address = 16'h1000;
    
    task body();
        my_sequence_item item;
        
        `uvm_info("SEQ", $sformatf("Starting sequence, %0d items", num_items), UVM_MEDIUM)
        
        repeat(num_items) begin
            item = my_sequence_item::type_id::create("item");
            start_item(item);
            assert(item.randomize());
            item.address = base_address + item_num;  // Override constraint
            finish_item(item);
            `uvm_info("SEQ", $sformatf("Sent: %s", item.convert2string()), UVM_DEBUG)
        end
    endtask
endclass

// Sequence with response
class my_sequence_with_response extends uvm_sequence #(my_sequence_item, my_sequence_item);
    `uvm_object_utils(my_sequence_with_response)
    
    task body();
        my_sequence_item req, rsp;
        req = my_sequence_item::type_id::create("req");
        start_item(req);
        assert(req.randomize());
        finish_item(req);
        get_response(rsp);  // Wait for driver response
        `uvm_info("SEQ", $sformatf("Got response: %s", rsp.convert2string()), UVM_MEDIUM)
    endtask
endclass

// Layered sequence (calling other sequences)
class layered_sequence extends uvm_sequence #(my_sequence_item);
    `uvm_object_utils(layered_sequence)
    
    task body();
        my_sequence seq1, seq2;
        seq1 = my_sequence::type_id::create("seq1");
        seq1.num_items = 5;
        seq1.start(m_sequencer);
        
        seq2 = my_sequence::type_id::create("seq2");
        seq2.num_items = 5;
        seq2.start(m_sequencer);
    endtask
endclass
```

**Sequencer:**
```systemverilog
class my_sequencer extends uvm_sequencer #(my_sequence_item);
    `uvm_component_utils(my_sequencer)
    
    function new(string name, uvm_component parent);
        super.new(name, parent);
    endfunction
endclass
```

**Driver-Sequencer Communication - Complete:**
```systemverilog
class my_driver extends uvm_driver #(my_sequence_item);
    `uvm_component_utils(my_driver)
    
    virtual task run_phase(uvm_phase phase);
        my_sequence_item req, rsp;
        
        forever begin
            // Get next item from sequencer (blocks until available)
            seq_item_port.get_next_item(req);
            
            `uvm_info("DRIVER", $sformatf("Driving: %s", req.convert2string()), UVM_MEDIUM)
            
            // Drive transaction to DUT
            drive_transaction(req);
            
            // Create and send response (optional, for sequences that need it)
            rsp = my_sequence_item::type_id::create("rsp");
            rsp.copy(req);
            rsp.data = read_from_dut();  // Read response data
            seq_item_port.put_response(rsp);
            
            // Signal item done (allows sequencer to send next item)
            seq_item_port.item_done();
        end
    endtask
    
    virtual task drive_transaction(my_sequence_item item);
        // Drive signals to DUT
        @(posedge vif.clk);
        vif.data <= item.data;
        vif.address <= item.address;
        vif.write <= item.write;
        @(posedge vif.clk);
    endtask
endclass

// Connection in agent
class my_agent extends uvm_agent;
    my_driver driver;
    my_sequencer sequencer;
    
    function void connect_phase(uvm_phase phase);
        super.connect_phase(phase);
        // Connect driver to sequencer (required for communication)
        driver.seq_item_port.connect(sequencer.seq_item_export);
    endfunction
endclass
```

**Key Syntax Patterns:**
- `class sequence_item extends uvm_sequence_item` - Sequence item base class
- `class sequence extends uvm_sequence #(item_type)` - Parameterized sequence
- `class sequencer extends uvm_sequencer #(item_type)` - Parameterized sequencer
- `start_item(item)` - Request item from sequencer (must call before randomize)
- `finish_item(item)` - Send item to sequencer (after randomize)
- `get_response(rsp)` - Get response from driver (for sequences with response)
- `seq_item_port.get_next_item(req)` - Driver gets item from sequencer (blocks)
- `seq_item_port.item_done()` - Signal item completion (allows next item)
- `seq_item_port.put_response(rsp)` - Send response to sequence
- `seq_item_port.connect(seq_item_export)` - Connect driver to sequencer (in connect_phase)
- `seq.start(sequencer)` - Start sequence on sequencer
- `assert(item.randomize())` - Randomize sequence item with constraints
- Constraints control randomization behavior (address ranges, data relationships)
- Sequences can call other sequences (layered sequences)
- Virtual sequences coordinate multiple sequencers

#### pyuvm Syntax

**Sequence Item - Enhanced Example:**
```python
class MySequenceItem(uvm_sequence_item):
    """Sequence item class with comprehensive features."""
    
    def __init__(self, name="MySequenceItem"):
        super().__init__(name)
        self.data = 0
        self.address = 0
        self.timestamp = 0
        self.write = False
        self.delay = 1
    
    def __str__(self):
        """String representation."""
        return (f"{self.get_name()}: data=0x{self.data:02X}, "
                f"addr=0x{self.address:04X}, write={self.write}")
    
    def randomize(self):
        """Randomize item fields (Python equivalent of SystemVerilog constraints)."""
        import random
        self.data = random.randint(0, 255)
        self.address = random.randint(0, 1023)
        self.write = random.choice([True, False])
        self.delay = random.randint(1, 10)
        return True
```

**Sequence - Multiple Patterns:**
```python
# Basic sequence
class MySequence(uvm_sequence):
    """Basic sequence generating items."""
    
    def __init__(self, name="MySequence"):
        super().__init__(name)
        self.num_items = 10
        self.base_address = 0x1000
    
    async def body(self):
        """Sequence body - generates and sends items."""
        self.logger.info(f"Starting sequence, {self.num_items} items")
        
        for i in range(self.num_items):
            item = MySequenceItem(f"item_{i}")
            item.randomize()
            item.address = self.base_address + i * 4  # Override
            
            await self.start_item(item)
            await self.finish_item(item)
            
            self.logger.debug(f"Sent: {item}")
        
        self.logger.info("Sequence complete")

# Sequence with response
class MySequenceWithResponse(uvm_sequence):
    """Sequence that waits for driver response."""
    
    async def body(self):
        """Sequence body with response handling."""
        item = MySequenceItem("req")
        item.randomize()
        
        await self.start_item(item)
        await self.finish_item(item)
        
        # Get response from driver
        response = await self.get_response()
        self.logger.info(f"Got response: {response}")

# Layered sequence (calling other sequences)
class LayeredSequence(uvm_sequence):
    """Sequence that calls other sequences."""
    
    async def body(self):
        """Start sub-sequences."""
        seq1 = MySequence("seq1")
        seq1.num_items = 5
        await seq1.start(self.m_sequencer)
        
        seq2 = MySequence("seq2")
        seq2.num_items = 5
        await seq2.start(self.m_sequencer)
```

**Sequencer:**
```python
class MyAgent(uvm_agent):
    """Agent with sequencer."""
    
    def build_phase(self):
        """Build phase."""
        self.seqr = uvm_sequencer("sequencer", self)
        self.driver = MyDriver.create("driver", self)
    
    def connect_phase(self):
        """Connect phase."""
        self.driver.seq_item_port.connect(self.seqr.seq_item_export)
```

**Driver-Sequencer Communication - Complete:**
```python
class MyDriver(uvm_driver):
    """Driver class with complete communication."""
    
    async def run_phase(self):
        """Run phase - consume items from sequencer."""
        while True:
            # Get next item from sequencer (blocks until available)
            item = await self.seq_item_port.get_next_item()
            
            self.logger.info(f"Driving: {item}")
            
            # Drive transaction to DUT
            await self.drive_transaction(item)
            
            # Create and send response (optional)
            response = MySequenceItem("rsp")
            response.copy(item)
            response.data = await self.read_from_dut()  # Read response
            await self.seq_item_port.put_response(response)
            
            # Signal item done (allows sequencer to send next item)
            await self.seq_item_port.item_done()
    
    async def drive_transaction(self, item):
        """Drive transaction to DUT."""
        # Example: Drive signals (using cocotb)
        # await Timer(1, unit="ns")
        # dut.data.value = item.data
        # dut.address.value = item.address
        # dut.write.value = item.write
        # await Timer(1, unit="ns")
        await Timer(10, unit="ns")  # Placeholder
    
    async def read_from_dut(self):
        """Read response from DUT."""
        # Example: Read from DUT
        # await Timer(1, unit="ns")
        # return dut.data.value
        return 0x00  # Placeholder
```

**Key Syntax Patterns:**
- `class MySequenceItem(uvm_sequence_item)` - Sequence item base class
- `class MySequence(uvm_sequence)` - Sequence class
- `async def body(self)` - Sequence body method (must be async)
- `await self.start_item(item)` - Request item from sequencer (async, must call before setting fields)
- `await self.finish_item(item)` - Send item to sequencer (async, after setting fields)
- `await self.get_response()` - Get response from driver (async, for sequences with response)
- `await self.seq_item_port.get_next_item()` - Driver gets item from sequencer (async, blocks)
- `await self.seq_item_port.item_done()` - Signal item completion (async, allows next item)
- `await self.seq_item_port.put_response(rsp)` - Send response to sequence (async)
- `await seq.start(sequencer)` - Start sequence on sequencer (async)
- `item.randomize()` - Randomize item fields (Python equivalent of SystemVerilog constraints)
- Sequences can call other sequences (layered sequences)
- All sequence operations are async in pyuvm
- Use `await` for all async operations

---

### 7. TLM (Transaction-Level Modeling) (IEEE 1800.2 Section 6)

#### SystemVerilog Syntax

**TLM Ports and Exports:**
```systemverilog
class my_driver extends uvm_driver #(my_transaction);
    uvm_seq_item_pull_port #(my_transaction) seq_item_port;
    
    function void build_phase(uvm_phase phase);
        seq_item_port = new("seq_item_port", this);
    endfunction
endclass

class my_sequencer extends uvm_sequencer #(my_transaction);
    uvm_seq_item_pull_imp #(my_transaction, my_sequencer) seq_item_export;
    
    function void build_phase(uvm_phase phase);
        seq_item_export = new("seq_item_export", this);
    endfunction
endclass

// Analysis ports
class my_monitor extends uvm_monitor;
    uvm_analysis_port #(my_transaction) ap;
    
    function void build_phase(uvm_phase phase);
        ap = new("ap", this);
    endfunction
    
    task run_phase(uvm_phase phase);
        my_transaction txn;
        // Monitor logic
        ap.write(txn);
    endtask
endclass

// Analysis export (subscriber)
class my_scoreboard extends uvm_scoreboard;
    uvm_analysis_imp #(my_transaction, my_scoreboard) analysis_export;
    
    function void build_phase(uvm_phase phase);
        analysis_export = new("analysis_export", this);
    endfunction
    
    function void write(my_transaction t);
        // Process transaction
    endfunction
endclass

// Connection
function void connect_phase(uvm_phase phase);
    monitor.ap.connect(scoreboard.analysis_export);
endfunction
```

**TLM FIFO:**
```systemverilog
class my_env extends uvm_env;
    uvm_tlm_fifo #(my_transaction) txn_fifo;
    
    function void build_phase(uvm_phase phase);
        txn_fifo = new("txn_fifo", this);
    endfunction
endclass
```

**Key Syntax Patterns:**
- `uvm_seq_item_pull_port #(type)` - Pull port
- `uvm_seq_item_pull_imp #(type, imp_type)` - Pull export
- `uvm_analysis_port #(type)` - Analysis port
- `uvm_analysis_imp #(type, imp_type)` - Analysis export
- `port.connect(export)` - TLM connection
- `port.write(item)` - Write to analysis port
- `export.write(item)` - Write implementation

#### pyuvm Syntax

**TLM Ports and Exports:**
```python
class MyDriver(uvm_driver):
    """Driver with TLM port."""
    
    def build_phase(self):
        """Build phase."""
        self.seq_item_port = uvm_seq_item_pull_port("seq_item_port", self)

class MySequencer(uvm_sequencer):
    """Sequencer with TLM export."""
    
    def build_phase(self):
        """Build phase."""
        self.seq_item_export = uvm_seq_item_pull_export("seq_item_export", self)

# Analysis ports
class MyMonitor(uvm_monitor):
    """Monitor with analysis port."""
    
    def build_phase(self):
        """Build phase."""
        self.ap = uvm_analysis_port("ap", self)
    
    async def run_phase(self):
        """Run phase."""
        txn = MyTransaction("txn")
        self.ap.write(txn)

# Analysis export (subscriber)
class MyScoreboard(uvm_scoreboard):
    """Scoreboard with analysis export."""
    
    def build_phase(self):
        """Build phase."""
        self.analysis_export = uvm_analysis_export("analysis_export", self)
    
    def write(self, t):
        """Write implementation."""
        # Process transaction
        pass

# Connection
def connect_phase(self):
    """Connect phase."""
    self.monitor.ap.connect(self.scoreboard.analysis_export)
```

**Key Syntax Patterns:**
- `uvm_seq_item_pull_port(name, parent)` - Pull port
- `uvm_seq_item_pull_export(name, parent)` - Pull export
- `uvm_analysis_port(name, parent)` - Analysis port
- `uvm_analysis_export(name, parent)` - Analysis export
- `port.connect(export)` - TLM connection
- `port.write(item)` - Write to port

---

### 8. Register Layer (IEEE 1800.2 Section 11)

#### SystemVerilog Syntax

**Register Model:**
```systemverilog
// Register field
class my_field extends uvm_reg_field;
    `uvm_object_utils(my_field)
    
    function new(string name = "my_field");
        super.new(name);
    endfunction
endclass

// Register
class my_register extends uvm_reg;
    rand my_field data;
    rand my_field control;
    
    `uvm_object_utils(my_register)
    
    function new(string name = "my_register");
        super.new(name, 32, UVM_NO_COVERAGE);
    endfunction
    
    virtual function void build();
        data = my_field::type_id::create("data");
        data.configure(this, 8, 0, "RW", 0, 8'h00, 1, 1, 1);
        
        control = my_field::type_id::create("control");
        control.configure(this, 8, 8, "RW", 0, 8'h00, 1, 1, 1);
    endfunction
endclass

// Register block
class my_reg_block extends uvm_reg_block;
    rand my_register reg1;
    
    `uvm_object_utils(my_reg_block)
    
    function new(string name = "my_reg_block");
        super.new(name, UVM_NO_COVERAGE);
    endfunction
    
    virtual function void build();
        reg1 = my_register::type_id::create("reg1");
        reg1.configure(this, null, "");
        reg1.build();
        
        default_map = create_map("default_map", 0, 4, UVM_LITTLE_ENDIAN);
        default_map.add_reg(reg1, 'h0, "RW");
        lock_model();
    endfunction
endclass

// Register operations
task run_phase(uvm_phase phase);
    uvm_status_e status;
    uvm_reg_data_t value;
    
    // Write register
    reg_block.reg1.write(status, 32'h12345678);
    
    // Read register
    reg_block.reg1.read(status, value);
    
    // Backdoor access
    reg_block.reg1.write(status, 32'hABCDEF00, .path(UVM_BACKDOOR));
endtask
```

**Key Syntax Patterns:**
- `class reg extends uvm_reg` - Register class
- `class reg_field extends uvm_reg_field` - Register field class
- `class reg_block extends uvm_reg_block` - Register block class
- `reg.write(status, value)` - Write register
- `reg.read(status, value)` - Read register
- `reg.write(status, value, .path(UVM_BACKDOOR))` - Backdoor access

#### pyuvm Syntax

**Register Model:**
```python
# Register field
class MyField(uvm_reg_field):
    """Register field class."""
    pass

# Register
class MyRegister(uvm_reg):
    """Register class."""
    
    def __init__(self, name="MyRegister"):
        super().__init__(name, 32)
        self.data = MyField("data")
        self.control = MyField("control")
    
    def build(self):
        """Build register fields."""
        self.data.configure(self, 8, 0, "RW", 0, 0x00, 1, 1, 1)
        self.control.configure(self, 8, 8, "RW", 0, 0x00, 1, 1, 1)

# Register block
class MyRegBlock(uvm_reg_block):
    """Register block class."""
    
    def __init__(self, name="MyRegBlock"):
        super().__init__(name)
        self.reg1 = MyRegister("reg1")
    
    def build(self):
        """Build register block."""
        self.reg1.configure(self, None, "")
        self.reg1.build()
        
        self.default_map = self.create_map("default_map", 0, 4, "UVM_LITTLE_ENDIAN")
        self.default_map.add_reg(self.reg1, 0x0, "RW")
        self.lock_model()
```

**Key Syntax Patterns:**
- `class MyReg(uvm_reg)` - Register class
- `class MyField(uvm_reg_field)` - Register field class
- `class MyRegBlock(uvm_reg_block)` - Register block class
- `reg.write(status, value)` - Write register
- `reg.read(status, value)` - Read register

---

### 9. Miscellaneous Utilities (IEEE 1800.2 Section 12)

#### SystemVerilog Syntax

**Command Line Processor:**
```systemverilog
// Get plusargs
string test_name;
if ($value$plusargs("TESTNAME=%s", test_name)) begin
    `uvm_info("CLP", $sformatf("Test name: %s", test_name), UVM_LOW)
end

int num_transactions;
if ($value$plusargs("NUM_TRANS=%d", num_transactions)) begin
    `uvm_info("CLP", $sformatf("Num transactions: %0d", num_transactions), UVM_LOW)
end
```

**Comparators:**
```systemverilog
uvm_in_order_class_comparator #(my_transaction) comparator;

function void build_phase(uvm_phase phase);
    comparator = new("comparator", this);
endfunction

function void compare(my_transaction expected, my_transaction actual);
    if (expected.data != actual.data) begin
        `uvm_error("COMP", "Data mismatch")
    end
endfunction
```

**String Utilities:**
```systemverilog
string s1 = "Hello";
string s2 = "World";
string result = {s1, " ", s2};  // Concatenation
int len = s1.len();               // Length
```

#### pyuvm Syntax

**Command Line Processor:**
```python
from pyuvm import uvm_cmdline_processor

# Get plusargs
clp = uvm_cmdline_processor()
test_name = clp.get_arg_value("+TESTNAME=")
num_trans = clp.get_arg_value("+NUM_TRANS=", int)
```

**Comparators:**
```python
from pyuvm import uvm_in_order_comparator

comparator = uvm_in_order_comparator("comparator", self)

def compare(expected, actual):
    """Compare transactions."""
    if expected.data != actual.data:
        self.logger.error("Data mismatch")
```

**String Utilities:**
```python
from pyuvm import uvm_string_utils

s1 = "Hello"
s2 = "World"
result = f"{s1} {s2}"  # Python f-string
length = len(s1)       # Python len()
```

**Key Syntax Patterns:**
- Command line argument parsing
- Comparison utilities
- String manipulation
- Math utilities
- Random utilities
- Object pools and queues
